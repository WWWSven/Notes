## ！！

[在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？](https://www.nowcoder.com/profile/8813748/myFollowings/detail/31436604)

## 得分点 

使用方式、主要特性、实现机制 

## 标准回答 

synchronized和Lock都是锁,都是线程同步的手段,它们的区别主要体现在如下三个方面： 

1. 使用方式的区别 

    - synchronized关键字可以作用在静态方法、实例方法和代码块上,它是一种隐式锁,即我们无需显式地获取和释放锁,所以使用起来十分的方便。在这种同步方式下,我们需要依赖**Monitor**（同步监视器）来实现线程通信。若关键字作用在静态方法上,则**Monitor**就是当前类的Class对象；若关键字作用在实例方法上,则**Monitor**就是当前实例（this）；若关键字作用在代码块上,则需要在关键字后面的小括号里显式指定一个对象作为**Monitor**。 

    - Lock接口是显式锁,即我们需要调用其内部定义的方法显式地加锁和解锁,相对于synchronized来说这显得有些繁琐,但是却提供了更大的灵活性。在这种同步方式下,我们需要依赖Condition对象来实现线程通信,该对象是由Lock对象创建出来的,依赖于Lock。每个Condition代表一个等待队列,而一个Lock可以创建多个Condition对象。相对而言,每个Monitor也代表一个等待队列,但synchronized只能有一个Monitor。所以,在实现线程通信方面,Lock接口具备更大的灵活性。 


2.  功能特性的区别 

     - synchronized是早期的API,Lock则是在JDK 1.5时引入的。
    
    
     - 在设计上,Lock弥补了synchronized的不足,它新增了一些特性,均是synchronized不具备的,这些特性包括： 
    
       可中断地获取锁：线程在获取锁的过程中可以被中断。 
    
       非阻塞地获取锁：该方法在调用后立刻返回,若能取到锁则返回true,否则返回false。 
    
       可超时地获取锁：若线程在到达超时时间后仍未获得锁,并且线程也没有被中断,则返回false。 
    

3.  实现机制的区别 

    - synchronized的底层是采用Java对象头来存储锁信息的,对象头包含三部分,分别是Mark Word、Class Metadata Address、Array length。

    - 其中,Mark Word用来存储对象的hashCode及锁信息,

      - Class Metadata Address用来存储对象类型的指针,

      - 而Array length则用来存储数组对象的长度。

    - AQS是队列同步器,是用来构建锁的基础框架,Lock实现类都是基于AQS实现的。AQS是基于模板方法模式进行设计的,所以锁的实现需要继承AQS并重写它指定的方法。AQS内部定义了一个FIFO的队列来实现线程的同步,同时还定义了同步状态来记录锁的信息。 


## 加分回答 

早期的synchronized性能较差,不如Lock。后来synchronized在实现上引入了锁升级机制,性能上已经不输给Lock了。所以,synchronized和Lock的区别主要不在性能上,因为**二者性能相差无几**。 

Java 6为了减少获取锁和释放锁带来的性能消耗,引入了偏向锁和轻量级锁。所以,从Java 6开始,锁一共被分为4种状态,级别由低到高依次是：**无锁、偏向锁、轻量级锁、重量级锁**。随着线程竞争情况的升级,锁的状态会从无锁状态逐步升级到重量级锁状态。锁可以升级却不能降级,这种只能升不能降的策略,是为了提高效率。 synchronized的早期设计并不包含锁升级机制,那个时候只有无锁和有锁之分。是为了提升性能才引入了偏向锁和轻量级锁,所以需要重点关注这两种状态的原理,以及它们的区别。 

- 偏向锁,顾名思义就是锁偏向于某一个线程。当一个线程访问同步块并获取锁时,会在对象头和栈帧中的锁记录里存储锁偏向的线程ID,以后该线程再进入和退出同步块时就不需要做加锁和解锁操作了,只需要简单地测试一下Mark Word里是否存储着自己的线程ID即可。 
- 轻量级锁,就是加锁时JVM先在当前线程栈帧中创建用于存储锁记录的空间,并将Mark Word复制到锁记录中,官方称之为Displaced Mark Word。然后线程尝试以CAS方式将Mark Word替换为指向锁记录的指针,如果成功则当前线程获得锁,如果失败则表示其他线程竞争锁,此时当前线程就会通过自旋来尝试获取锁。